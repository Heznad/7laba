# 7laba
Тема лабораторной работы: Преобразование и анализ кода с использованием Clang и LLVM.  
Цель работы: Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.  
Задание:   
1. Установить Clang и LLVM;  
2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;  
3. Использовать opt для применения базовой комплексной оптимизации (например, О2);  
4. Построить граф потока управления (CFG) для оптимизированной программы;  
5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы.

## Оглавление
[1. Установка и подготовка среды](#1-установка-и-подготовка-среды)  
[2. Исходный код](#2-исходный-код)  
[3. Получение AST](#3-получение-ast)  
[4. Генерация LLVM IR](#4-генерация-llvm-ir)  
[5. Оптимизация IR](#5-оптимизация-ir)  
[6. Граф потока управления программы](#6-граф-потока-управления-программы)  
[Вывод](#выводы)  
[Ответы на контрольные вопросы](#ответы-на-контрольные-вопросы)  

## Ход работы
### 1. Установка и подготовка среды
Работа выполнялась в среде Ubuntu 22.04.05.  
Команда установки:  
```
sudo apt install clang llvm
```
![71](https://github.com/user-attachments/assets/53fa7b7e-ca84-4eda-9eaa-10402f19004b)  
Рисунок 1 - Установка компилятора clang и инструмента для анализа и оптимизации кода llvm.

### 2. Исходный код
![image](https://github.com/user-attachments/assets/7cbfb5ab-e10e-473a-993f-f9a64130c952)  
Рисунок 2 - Исходный код в файле main.c.

### 3. Получение AST
Команда для получение абстрактного синтаксического дерева(AST):
```
clang -Xclang -ast-dump -fsyntax-only main.c
```
![image](https://github.com/user-attachments/assets/b3852a6a-e283-40df-9f7e-3c543e3c7290)  
Рисунок 3 - Полученное AST файла main.c

### 4. Генерация LLVM IR
Команда для получения низкоуровневого промежуточного представления кода, которое используется компилятором Clang для оптимизаций и дальнейшей генерации машинного кода.:
```
clang -S -emit-llvm main.c -o main.ll
```
![73](https://github.com/user-attachments/assets/e53db842-5200-4dcf-ae8f-8865adecb1bb)
Рисунок 4 - Генерация файла main.ll, содержащий LLVM Intermediate Representation (IR) в текстовом формате.  

### 5. Оптимизация IR
Команда для генерирации LLVM IR в текстовом формате, но с отключёнными оптимизациями:
```
clang -O0 -S -emit-llvm main.c -o main_O0.ll
```
![74](https://github.com/user-attachments/assets/9591663a-1d79-4bf6-a1dc-be2cd90cc12d)  
Рисунок 5 - Генерация LLVM IR файла main_O0.ll.  

Команда для генерирации LLVM IR в текстовом формате, но с комплексной оптимизацией среднего уровня:
Команда:
```
clang -O2 -S -emit-llvm main.c -o main_O2.ll
```
![75](https://github.com/user-attachments/assets/36befd3d-55d6-4d9f-bc16-a26eb2341aaf)  
Рисунок 6 - Генерация оптимизированного LLVM IR файла main_O2.ll.  

Команда для сравнения двух LLVM IR файлов:
```
diff main_O0.ll main_O2.ll
```
![76](https://github.com/user-attachments/assets/1dea4e07-d722-4cf2-97cb-918122601337)  
Рисунок 7 - Сравнение двух файлов main_O0.ll и main_O2.ll

### 6. Граф потока управления программы
Команда для генерации оптимизированного LLVM IR: 
```
clang -O2 -S -emit-llvm main.c -o main.ll
```
Команда для генерации .dot-файлов CFG для функций: 
```
opt -dot-cfg -disable-output main.ll
```
![77](https://github.com/user-attachments/assets/5d6059b2-e8c0-4823-bb4f-02cf8b855b1c)  
Рисунок 8 - Команды для генерации LLVM IR и .dot-файлов CFG с выводом всех найденных функций name.dot.

Команда для установки библиотеки Graphviz:
```
sudo apt install graphviz
```
![78](https://github.com/user-attachments/assets/202328ae-a7d7-4fa1-94bf-f29d760eebd1)  
Рисунок 9 - Установка библиотеки Graphviz.

Команды для преобразования файлов с расширением .dot в .png с помощью Graphviz:
```
dot -Tpng .main.dot -o cfg_main.png
dot -Tpng .square.dot -o cfg_square.png
```
Команды для просмотра файлов с CGF:
```
xdg-open cfg_main.png
xdg-open cfg_square.png
```
![79](https://github.com/user-attachments/assets/f8115da4-4a10-48ef-bdee-124d5ee1a265)  
Рисунок 10 - Граф потока управления для функции main.

![80](https://github.com/user-attachments/assets/ed73d712-8ab7-4676-9aeb-9ada89941455)  
Рисунок 11 - Граф потока управления для функции square.

## Выводы
● С помощью Clang можно получить полную структуру AST и IR, а также CGF;  
● LLVM предоставляет гибкие инструменты анализа и оптимизации;  
● Промежуточное представление кода удобно для написания компиляторных трансформаций.  

## Ответы на контрольные вопросы
### 1. Что такое Clang, и какова его роль в процессе компиляции программ?  
Clang — это компилятор для C, C++ и Objective-C, часть LLVM. Он преобразует исходный код в машинный или промежуточный (IR), выполняя препроцессинг, анализ и оптимизацию.  

### 2. Что представляет собой LLVM и как он используется в современных компиляторах?  
LLVM — это модульная платформа для разработки компиляторов, использующая универсальное промежуточное представление (IR) для оптимизации и генерации машинного кода. В современных компиляторах (Clang, Rust, Swift) LLVM отвечает за анализ, оптимизацию и поддержку разных архитектур процессоров.  

### 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?  
AST отражает структуру исходного кода в виде дерева с узлами (операторы, выражения, объявления), сохраняя высокоуровневую семантику языка. LLVM IR — это низкоуровневое линейное представление, близкое к машинному коду, оптимизированное для анализа и преобразований (например, циклов или арифметики).  
Ключевое отличие: AST зависит от языка (C++, Rust и т.д.), а LLVM IR — универсален и используется для кросс-языковой оптимизации и генерации кода под разные процессоры.  

### 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?  
Промежуточное представление (IR) нужно, чтобы отделить анализ исходного кода от генерации машинного кода, упрощая поддержку новых языков и архитектур. Оно позволяет применять универсальные оптимизации до привязки к конкретному процессору. 

### 5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?  
**alloca** в LLVM IR выделяет память в стеке функции под локальные переменные и возвращает указатель на неё. Используется для хранения адресуемых данных. Автоматически освобождается при завершении функции, аналогично обычным стековым переменным в C.  

### 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?  
Оптимизация кода делает программу быстрее и компактнее, удаляя лишние операции и эффективнее используя ресурсы процессора. Главные задачи — ускорение вычислений, уменьшение размера кода и адаптация под конкретное оборудование. Без неё программы работали бы медленнее и тратили больше памяти.  

### 7. Что такое SSA-форма и почему она важна при оптимизации программ?  
SSA-форма (Static Single Assignment) — это представление программы, где каждая переменная инициализируется лишь единожды, что делает зависимости между данными явными и однозначными.  
Ключевая польза:  
Позволяет компилятору легко отслеживать поток данных, упрощая такие оптимизации, как удаление общих подвыражений и продвижение констант.  
Особенно полезна для анализа и преобразования циклов, где важно точно определять изменяемые переменные.  

### 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?  
Граф потока управления (CFG) — это визуальное представление структуры программы в виде связанных блоков кода, где каждый блок содержит последовательность инструкций, а стрелки между ними показывают возможные пути выполнения. Такой граф помогает компилятору анализировать и оптимизировать код, выявляя недостижимые участки, избыточные условия и потенциальные точки ветвления. Благодаря CFG можно эффективно применять оптимизации, связанные с анализом циклов, предсказанием переходов и распределением ресурсов.

### 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?  
В LLVM IR арифметические операции записываются как инструкции с явным указанием типа, например:  
%res = add i32 %a, %b.  
Каждая операция создаёт новое значение в SSA-форме, что упрощает анализ и оптимизацию кода.
Для умножения,сложения,вычитания и деления используются mul,add,sub,sdiv, а типы данных (как i32) всегда указываются явно, например: %sum = mul i32 %x, %y.  

### 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?  
Функции в LLVM IR являются самостоятельными единицами оптимизации, поскольку их изолированная структура позволяет применять преобразования локально, не анализируя всю программу. Это даёт возможность эффективно выполнять как внутрипроцедурные оптимизации, так и межпроцедурные (анализируя взаимодействия между функциями). Такой подход значительно ускоряет процесс компиляции и улучшает качество оптимизаций.  

### 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?  
Короткая функция в LLVM IR, вызываемая единожды, обычно подставляется на месте вызова и затем удаляется. Это устраняет накладные расходы на вызов.  

### 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?  
Использование LLVM IR и CFG даёт ключевые преимущества для автоматических оптимизаций по сравнению с анализом исходного C-кода:  
1. Абстракция от языка — IR унифицирует разные языки (C, C++, Rust и др.), позволяя применять общие оптимизации без привязки к синтаксису.  
2. Точный контроль потока — CFG явно показывает ветвления и циклы, упрощая анализ достижимости и удаление мёртвого кода.  
3. Низкоуровневые возможности — IR ближе к машинному коду, что позволяет оптимизировать даже «неочевидные» случаи (например, замену деления на сдвиги).   
Пример: На C компилятору сложно доказать, что цикл for (int i=0; i<10; i++) всегда выполнится 10 раз, а в IR это сразу видно в CFG и SSA-форме.
